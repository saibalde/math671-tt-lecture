function ttm = tt_ker(ker, relAcc, d)
%TT_KER Construct TT approximation to kernel using TT-SVD
%
%   tt_ker(ker, relAcc, d) computes the TT approximation of the matrix
%   generated by evauating kernel handle fun at 2^d uniformly spaced
%   discretization points along each dimension in [0, 1]^2:
%
%       >> x = linspace(0, 1, 2^d + 1); x = x(1 : end - 1); x = x';
%       >> h = x(2) - x(1);
%       >> x = x + 0.5 * h;     % center points
%       >> K = ker(x, x'); 
%
%   The TT decomposition is then obtained by running TT-SVD with relative
%   accuracy relAcc on the tensorized kernel value matrix.

N = 2^d;
x = linspace(0, 1, N + 1)'; x = x(1 : N);
h = x(2) - x(1);
x = 0.5 * h + x;
k = ker(x, x');

K = reshape(k, 2 * ones(1, 2 * d));
dimorder = zeros(1, 2 * d);
dimorder(1 : 2 : 2 * d) = 1 : d;
dimorder(2 : 2 : 2 * d) = d + 1 : 2 * d;
K = permute(K, dimorder);
K = reshape(K, 4 * ones(1, d));

ttk = tt_tensor(K, relAcc);
ttm = tt_matrix(ttk, 2 * ones(1, d), 2 * ones(1, d));

relErr = norm(full(ttm) - k) / norm(k);
fprintf('relative error in compression in operator norm is %.e\n', relErr);

relErr = norm(full(ttm) - k, 'fro') / norm(k, 'fro');
fprintf('relative error in compression in Frobenius norm is %.e\n', ...
        relErr);

end